# 간단한 캐시 메모리 동작
<hr/>

## 목표
<hr/>

이론으로 배웠던 캐시 동작을 흉내내본다.<br/>
<strong>32비트 컴퓨터</strong>의 캐시 메모리 적재/교체, 캐시 히트/미스의 동작을 구현한다.<br/>
실제 하나의 메모리 덩어리로 이루어진 캐시라고 생각한다. (1차원 배열 외에 다른 자료구조 사용 X) <br/>

<hr/>

## 구성
<hr/>
+ 캐시 오브젝트
  + 메모리 : 32Kbytes
  + 라인 : 64bytes
  + 웨이 : 8
  + 인덱스 : 0 ~ 63  

+ 라인 추가 정보
  + 태그 : 2KB (4bytes, 총 512개)
  + 사용 플래그 : 512bytes (1bytes, 총 512개)
  + 접근 플래그 : 512bytes (1bytes, 총 512개)

+ 인덱스 구성
  + 캐시 인덱스 : 8개의 캐시 라인을 묶어서 하나의 캐시 인덱스로 구현
  + 태그 인덱스 : 8개의 태그 라인을 묶어서 하나의 태그 인덱스로 구현
  + 플래그 : 메모리 라인 개수 만큼 인덱스로 구현
  + 데이터 주소
    + 주소에서 Tag, Index, Offset를 얻는다.
    + 캐시 라인에 0 ~ 63까지 있기 때문에 2의6승, 즉 하위 1 ~ 6비트까지가 Offset
    + 인덱스가 0 ~ 63까지 있기 때문에 2의 6승, 즉 하위 7 ~ 12비트까지가 Index
    + 나머지 주소의 비트 수(20비트) 만큼 태그를 구성한다.
<hr/>

## 동작
<hr/>

### 캐시 히트/미스
1. 데이터의 주소와 사이즈를 캐시 오브젝트에 전달한다.
2. 데이터 주소에서 태그, 인덱스, 오프셋을 구한다.
3. 해당 인덱스의 시작 주소를 구한다.
4. 인덱스의 시작 주소에서 웨이만큼 반복하여 일치하는 태그 값이 있는지 확인한다.
5. 일치하는 태그가 있을 경우 오프셋에서 사이즈 만큼 데이터를 담아준다.</br>
6. 일치하는 태그가 없을 경우 데이터 적재/교체로 넘어간다.
7. <strong> 사이즈가 남았을 경우 필요한 다음 주소로 갱신한 후 1번 부터 다시 시작한다.</strong>

### 데이터 적재/교체
0. 캐시 라인 크기 만큼 한번에 적재하고 교체한다.
1. 데이터 주소에서 태그, 인덱스, 데이터의 주소가 포함된 캐시 라인 크기 만큼의 경계를 갖는 시작 주소를 구한다.
2. 해당 인덱스에서 저장할 공간(웨이)이 있는지 찾는다. (우선 순위는 빈 공간, 접근의 수가 적은 공간)
3. 데이터 인덱스 시작주소와 태그 인덱스 시작주소로 부터 해당 인덱스에 있는 웨이의 시작 주소를 구해준다.
4. 플래그 값을 초기화 해준다.
5. 태그 값을 저장한다.
6. 캐시 라인의 크기 만큼의 경계를 갖는 시작주소로 부터 캐시 라인 크기 만큼 적재한다.
